{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer,\n    Emitter = require('events').EventEmitter,\n    util = require('util'),\n    streams = require('../streams'),\n    Headers = require('./headers'),\n    Reader = require('./stream_reader');\n\nvar Base = function Base(request, url, options) {\n  Emitter.call(this);\n  Base.validateOptions(options || {}, ['maxLength', 'masking', 'requireMasking', 'protocols']);\n  this._request = request;\n  this._reader = new Reader();\n  this._options = options || {};\n  this._maxLength = this._options.maxLength || this.MAX_LENGTH;\n  this._headers = new Headers();\n  this.__queue = [];\n  this.readyState = 0;\n  this.url = url;\n  this.io = new streams.IO(this);\n  this.messages = new streams.Messages(this);\n\n  this._bindEventListeners();\n};\n\nutil.inherits(Base, Emitter);\n\nBase.isWebSocket = function (request) {\n  var connection = request.headers.connection || '',\n      upgrade = request.headers.upgrade || '';\n  return request.method === 'GET' && connection.toLowerCase().split(/ *, */).indexOf('upgrade') >= 0 && upgrade.toLowerCase() === 'websocket';\n};\n\nBase.validateOptions = function (options, validKeys) {\n  for (var key in options) {\n    if (validKeys.indexOf(key) < 0) throw new Error('Unrecognized option: ' + key);\n  }\n};\n\nvar instance = {\n  // This is 64MB, small enough for an average VPS to handle without\n  // crashing from process out of memory\n  MAX_LENGTH: 0x3ffffff,\n  STATES: ['connecting', 'open', 'closing', 'closed'],\n  _bindEventListeners: function _bindEventListeners() {\n    var self = this; // Protocol errors are informational and do not have to be handled\n\n    this.messages.on('error', function () {});\n    this.on('message', function (event) {\n      var messages = self.messages;\n      if (messages.readable) messages.emit('data', event.data);\n    });\n    this.on('error', function (error) {\n      var messages = self.messages;\n      if (messages.readable) messages.emit('error', error);\n    });\n    this.on('close', function () {\n      var messages = self.messages;\n      if (!messages.readable) return;\n      messages.readable = messages.writable = false;\n      messages.emit('end');\n    });\n  },\n  getState: function getState() {\n    return this.STATES[this.readyState] || null;\n  },\n  addExtension: function addExtension(extension) {\n    return false;\n  },\n  setHeader: function setHeader(name, value) {\n    if (this.readyState > 0) return false;\n\n    this._headers.set(name, value);\n\n    return true;\n  },\n  start: function start() {\n    if (this.readyState !== 0) return false;\n    if (!Base.isWebSocket(this._request)) return this._failHandshake(new Error('Not a WebSocket request'));\n    var response;\n\n    try {\n      response = this._handshakeResponse();\n    } catch (error) {\n      return this._failHandshake(error);\n    }\n\n    this._write(response);\n\n    if (this._stage !== -1) this._open();\n    return true;\n  },\n  _failHandshake: function _failHandshake(error) {\n    var headers = new Headers();\n    headers.set('Content-Type', 'text/plain');\n    headers.set('Content-Length', Buffer.byteLength(error.message, 'utf8'));\n    headers = ['HTTP/1.1 400 Bad Request', headers.toString(), error.message];\n\n    this._write(Buffer.from(headers.join('\\r\\n'), 'utf8'));\n\n    this._fail('protocol_error', error.message);\n\n    return false;\n  },\n  text: function text(message) {\n    return this.frame(message);\n  },\n  binary: function binary(message) {\n    return false;\n  },\n  ping: function ping() {\n    return false;\n  },\n  pong: function pong() {\n    return false;\n  },\n  close: function close(reason, code) {\n    if (this.readyState !== 1) return false;\n    this.readyState = 3;\n    this.emit('close', new Base.CloseEvent(null, null));\n    return true;\n  },\n  _open: function _open() {\n    this.readyState = 1;\n\n    this.__queue.forEach(function (args) {\n      this.frame.apply(this, args);\n    }, this);\n\n    this.__queue = [];\n    this.emit('open', new Base.OpenEvent());\n  },\n  _queue: function _queue(message) {\n    this.__queue.push(message);\n\n    return true;\n  },\n  _write: function _write(chunk) {\n    var io = this.io;\n    if (io.readable) io.emit('data', chunk);\n  },\n  _fail: function _fail(type, message) {\n    this.readyState = 2;\n    this.emit('error', new Error(message));\n    this.close();\n  }\n};\n\nfor (var key in instance) {\n  Base.prototype[key] = instance[key];\n}\n\nBase.ConnectEvent = function () {};\n\nBase.OpenEvent = function () {};\n\nBase.CloseEvent = function (code, reason) {\n  this.code = code;\n  this.reason = reason;\n};\n\nBase.MessageEvent = function (data) {\n  this.data = data;\n};\n\nBase.PingEvent = function (data) {\n  this.data = data;\n};\n\nBase.PongEvent = function (data) {\n  this.data = data;\n};\n\nmodule.exports = Base;","map":null,"metadata":{},"sourceType":"script"}