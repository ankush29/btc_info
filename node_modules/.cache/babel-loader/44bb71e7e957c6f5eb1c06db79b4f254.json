{"ast":null,"code":"'use strict';\n\nvar RingBuffer = require('./ring_buffer');\n\nvar Functor = function Functor(session, method) {\n  this._session = session;\n  this._method = method;\n  this._queue = new RingBuffer(Functor.QUEUE_SIZE);\n  this._stopped = false;\n  this.pending = 0;\n};\n\nFunctor.QUEUE_SIZE = 8;\n\nFunctor.prototype.call = function (error, message, callback, context) {\n  if (this._stopped) return;\n  var record = {\n    error: error,\n    message: message,\n    callback: callback,\n    context: context,\n    done: false\n  },\n      called = false,\n      self = this;\n\n  this._queue.push(record);\n\n  if (record.error) {\n    record.done = true;\n\n    this._stop();\n\n    return this._flushQueue();\n  }\n\n  var handler = function handler(err, msg) {\n    if (!(called ^ (called = true))) return;\n\n    if (err) {\n      self._stop();\n\n      record.error = err;\n      record.message = null;\n    } else {\n      record.message = msg;\n    }\n\n    record.done = true;\n\n    self._flushQueue();\n  };\n\n  try {\n    this._session[this._method](message, handler);\n  } catch (err) {\n    handler(err);\n  }\n};\n\nFunctor.prototype._stop = function () {\n  this.pending = this._queue.length;\n  this._stopped = true;\n};\n\nFunctor.prototype._flushQueue = function () {\n  var queue = this._queue,\n      record;\n\n  while (queue.length > 0 && queue.peek().done) {\n    record = queue.shift();\n\n    if (record.error) {\n      this.pending = 0;\n      queue.clear();\n    } else {\n      this.pending -= 1;\n    }\n\n    record.callback.call(record.context, record.error, record.message);\n  }\n};\n\nmodule.exports = Functor;","map":null,"metadata":{},"sourceType":"script"}