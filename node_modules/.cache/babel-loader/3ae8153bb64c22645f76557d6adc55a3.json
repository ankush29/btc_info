{"ast":null,"code":"var Stream = require('stream').Stream,\n    util = require('util'),\n    driver = require('websocket-driver'),\n    Headers = require('websocket-driver/lib/websocket/driver/headers'),\n    API = require('./websocket/api'),\n    EventTarget = require('./websocket/api/event_target'),\n    Event = require('./websocket/api/event');\n\nvar EventSource = function EventSource(request, response, options) {\n  this.writable = true;\n  options = options || {};\n  this._stream = response.socket;\n  this._ping = options.ping || this.DEFAULT_PING;\n  this._retry = options.retry || this.DEFAULT_RETRY;\n  var scheme = driver.isSecureRequest(request) ? 'https:' : 'http:';\n  this.url = scheme + '//' + request.headers.host + request.url;\n  this.lastEventId = request.headers['last-event-id'] || '';\n  this.readyState = API.CONNECTING;\n  var headers = new Headers(),\n      self = this;\n\n  if (options.headers) {\n    for (var key in options.headers) {\n      headers.set(key, options.headers[key]);\n    }\n  }\n\n  if (!this._stream || !this._stream.writable) return;\n  process.nextTick(function () {\n    self._open();\n  });\n\n  this._stream.setTimeout(0);\n\n  this._stream.setNoDelay(true);\n\n  var handshake = 'HTTP/1.1 200 OK\\r\\n' + 'Content-Type: text/event-stream\\r\\n' + 'Cache-Control: no-cache, no-store\\r\\n' + 'Connection: close\\r\\n' + headers.toString() + '\\r\\n' + 'retry: ' + Math.floor(this._retry * 1000) + '\\r\\n\\r\\n';\n\n  this._write(handshake);\n\n  this._stream.on('drain', function () {\n    self.emit('drain');\n  });\n\n  if (this._ping) this._pingTimer = setInterval(function () {\n    self.ping();\n  }, this._ping * 1000);\n  ['error', 'end'].forEach(function (event) {\n    self._stream.on(event, function () {\n      self.close();\n    });\n  });\n};\n\nutil.inherits(EventSource, Stream);\n\nEventSource.isEventSource = function (request) {\n  if (request.method !== 'GET') return false;\n  var accept = (request.headers.accept || '').split(/\\s*,\\s*/);\n  return accept.indexOf('text/event-stream') >= 0;\n};\n\nvar instance = {\n  DEFAULT_PING: 10,\n  DEFAULT_RETRY: 5,\n  _write: function _write(chunk) {\n    if (!this.writable) return false;\n\n    try {\n      return this._stream.write(chunk, 'utf8');\n    } catch (e) {\n      return false;\n    }\n  },\n  _open: function _open() {\n    if (this.readyState !== API.CONNECTING) return;\n    this.readyState = API.OPEN;\n    var event = new Event('open');\n    event.initEvent('open', false, false);\n    this.dispatchEvent(event);\n  },\n  write: function write(message) {\n    return this.send(message);\n  },\n  end: function end(message) {\n    if (message !== undefined) this.write(message);\n    this.close();\n  },\n  send: function send(message, options) {\n    if (this.readyState > API.OPEN) return false;\n    message = String(message).replace(/(\\r\\n|\\r|\\n)/g, '$1data: ');\n    options = options || {};\n    var frame = '';\n    if (options.event) frame += 'event: ' + options.event + '\\r\\n';\n    if (options.id) frame += 'id: ' + options.id + '\\r\\n';\n    frame += 'data: ' + message + '\\r\\n\\r\\n';\n    return this._write(frame);\n  },\n  ping: function ping() {\n    return this._write(':\\r\\n\\r\\n');\n  },\n  close: function close() {\n    if (this.readyState > API.OPEN) return false;\n    this.readyState = API.CLOSED;\n    this.writable = false;\n    if (this._pingTimer) clearInterval(this._pingTimer);\n    if (this._stream) this._stream.end();\n    var event = new Event('close');\n    event.initEvent('close', false, false);\n    this.dispatchEvent(event);\n    return true;\n  }\n};\n\nfor (var method in instance) {\n  EventSource.prototype[method] = instance[method];\n}\n\nfor (var key in EventTarget) {\n  EventSource.prototype[key] = EventTarget[key];\n}\n\nmodule.exports = EventSource;","map":null,"metadata":{},"sourceType":"script"}