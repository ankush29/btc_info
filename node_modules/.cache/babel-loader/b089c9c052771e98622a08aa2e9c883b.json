{"ast":null,"code":"/*jshint node:true */\nvar assert = require('assert');\n\nexports.HTTPParser = HTTPParser;\n\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n}\n\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\n\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE';\nvar kOnHeaders = HTTPParser.kOnHeaders = 0;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 1;\nvar kOnBody = HTTPParser.kOnBody = 2;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 3; // Some handler stubs, needed for compatibility\n\nHTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n  get: function get() {\n    // hack for backward compatibility\n    compatMode0_12 = false;\n    return 4;\n  }\n});\nvar methods = exports.methods = HTTPParser.methods = ['DELETE', 'GET', 'HEAD', 'POST', 'PUT', 'CONNECT', 'OPTIONS', 'TRACE', 'COPY', 'LOCK', 'MKCOL', 'MOVE', 'PROPFIND', 'PROPPATCH', 'SEARCH', 'UNLOCK', 'BIND', 'REBIND', 'UNBIND', 'ACL', 'REPORT', 'MKACTIVITY', 'CHECKOUT', 'MERGE', 'M-SEARCH', 'NOTIFY', 'SUBSCRIBE', 'UNSUBSCRIBE', 'PATCH', 'PURGE', 'MKCALENDAR', 'LINK', 'UNLINK'];\nHTTPParser.prototype.reinitialize = HTTPParser;\n\nHTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function () {};\n\nHTTPParser.prototype._compatMode0_11 = false;\n\nHTTPParser.prototype.getAsyncId = function () {\n  return 0;\n};\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\n\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  } // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n\n\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n\n    this.hadError = true;\n    return err;\n  }\n\n  this.chunk = null;\n  length = this.offset - start;\n\n  if (headerState[this.state]) {\n    this.headerSize += length;\n\n    if (this.headerSize > HTTPParser.maxHeaderSize) {\n      return new Error('max header size exceeded');\n    }\n  }\n\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\n\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n}; // These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\n\n\nHTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function () {}; //For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\n\n\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) {\n      // \\n\n      var line = this.line + chunk.toString('ascii', this.offset, i);\n\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  } //line split over multiple chunks\n\n\n  this.line += chunk.toString('ascii', this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\n\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n\n  if (k) {\n    // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\n\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n\n  if (!line) {\n    return;\n  }\n\n  var match = requestExp.exec(line);\n\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n\n  if (match[1] === 'CONNECT') {\n    this.info.upgrade = true;\n  }\n\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n\n  if (!line) {\n    return;\n  }\n\n  var match = responseExp.exec(line);\n\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4]; // Implied zero length.\n\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n\n  if (this.body_bytes !== null || this.isChunked) {\n    // || skipBody\n    return true;\n  }\n\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  var info = this.info;\n\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n\n          break;\n\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n\n        case 'upgrade':\n          info.upgrade = true;\n          break;\n      }\n    }\n\n    if (this.isChunked && hasContentLength) {\n      throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive(); //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n\n    var skipBody;\n\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n\n    if (info.upgrade || skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest();\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  this.body_bytes = parseInt(line, 16);\n\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n}; // backward compat to node < 0.11.6\n\n\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function get() {\n      return this[k];\n    },\n    set: function set(to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      return this[k] = to;\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}","map":null,"metadata":{},"sourceType":"script"}