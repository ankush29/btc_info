{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var FayeWebsocket,\n      RawWebsocketSessionReceiver,\n      Transport,\n      WebSocketReceiver,\n      transport,\n      utils,\n      extend = function extend(child, parent) {\n    for (var key in parent) {\n      if (hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  },\n      hasProp = {}.hasOwnProperty;\n\n  FayeWebsocket = require('faye-websocket');\n  utils = require('./utils');\n  transport = require('./transport');\n  exports.app = {\n    _websocket_check: function _websocket_check(req, connection, head) {\n      if (!FayeWebsocket.isWebSocket(req)) {\n        throw {\n          status: 400,\n          message: 'Not a valid websocket request'\n        };\n      }\n    },\n    sockjs_websocket: function sockjs_websocket(req, connection, head) {\n      var ws;\n\n      this._websocket_check(req, connection, head);\n\n      ws = new FayeWebsocket(req, connection, head, null, this.options.faye_server_options);\n\n      ws.onopen = function (_this) {\n        return function () {\n          return transport.registerNoSession(req, _this, new WebSocketReceiver(ws, connection));\n        };\n      }(this);\n\n      return true;\n    },\n    raw_websocket: function raw_websocket(req, connection, head) {\n      var ver, ws;\n\n      this._websocket_check(req, connection, head);\n\n      ver = req.headers['sec-websocket-version'] || '';\n\n      if (['8', '13'].indexOf(ver) === -1) {\n        throw {\n          status: 400,\n          message: 'Only supported WebSocket protocol is RFC 6455.'\n        };\n      }\n\n      ws = new FayeWebsocket(req, connection, head, null, this.options.faye_server_options);\n\n      ws.onopen = function (_this) {\n        return function () {\n          return new RawWebsocketSessionReceiver(req, connection, _this, ws);\n        };\n      }(this);\n\n      return true;\n    }\n  };\n\n  WebSocketReceiver = function (superClass) {\n    extend(WebSocketReceiver, superClass);\n    WebSocketReceiver.prototype.protocol = \"websocket\";\n\n    function WebSocketReceiver(ws1, connection1) {\n      var x;\n      this.ws = ws1;\n      this.connection = connection1;\n\n      try {\n        this.connection.setKeepAlive(true, 5000);\n        this.connection.setNoDelay(true);\n      } catch (error) {\n        x = error;\n      }\n\n      this.ws.addEventListener('message', function (_this) {\n        return function (m) {\n          return _this.didMessage(m.data);\n        };\n      }(this));\n\n      this.heartbeat_cb = function (_this) {\n        return function () {\n          return _this.heartbeat_timeout();\n        };\n      }(this);\n\n      WebSocketReceiver.__super__.constructor.call(this, this.connection);\n    }\n\n    WebSocketReceiver.prototype.setUp = function () {\n      WebSocketReceiver.__super__.setUp.apply(this, arguments);\n\n      return this.ws.addEventListener('close', this.thingy_end_cb);\n    };\n\n    WebSocketReceiver.prototype.tearDown = function () {\n      this.ws.removeEventListener('close', this.thingy_end_cb);\n      return WebSocketReceiver.__super__.tearDown.apply(this, arguments);\n    };\n\n    WebSocketReceiver.prototype.didMessage = function (payload) {\n      var i, len, message, msg, results, x;\n\n      if (this.ws && this.session && payload.length > 0) {\n        try {\n          message = JSON.parse(payload);\n        } catch (error) {\n          x = error;\n          return this.didClose(3000, 'Broken framing.');\n        }\n\n        if (payload[0] === '[') {\n          results = [];\n\n          for (i = 0, len = message.length; i < len; i++) {\n            msg = message[i];\n            results.push(this.session.didMessage(msg));\n          }\n\n          return results;\n        } else {\n          return this.session.didMessage(message);\n        }\n      }\n    };\n\n    WebSocketReceiver.prototype.doSendFrame = function (payload) {\n      var x;\n\n      if (this.ws) {\n        try {\n          this.ws.send(payload);\n          return true;\n        } catch (error) {\n          x = error;\n        }\n      }\n\n      return false;\n    };\n\n    WebSocketReceiver.prototype.didClose = function (status, reason) {\n      var x;\n\n      if (status == null) {\n        status = 1000;\n      }\n\n      if (reason == null) {\n        reason = \"Normal closure\";\n      }\n\n      WebSocketReceiver.__super__.didClose.apply(this, arguments);\n\n      try {\n        this.ws.close(status, reason, false);\n      } catch (error) {\n        x = error;\n      }\n\n      this.ws = null;\n      return this.connection = null;\n    };\n\n    WebSocketReceiver.prototype.heartbeat = function () {\n      var hto_ref, supportsHeartbeats;\n      supportsHeartbeats = this.ws.ping(null, function () {\n        return clearTimeout(hto_ref);\n      });\n\n      if (supportsHeartbeats) {\n        return hto_ref = setTimeout(this.heartbeat_cb, 10000);\n      } else {\n        return WebSocketReceiver.__super__.heartbeat.apply(this, arguments);\n      }\n    };\n\n    WebSocketReceiver.prototype.heartbeat_timeout = function () {\n      if (this.session != null) {\n        return this.session.close(3000, 'No response from heartbeat');\n      }\n    };\n\n    return WebSocketReceiver;\n  }(transport.GenericReceiver);\n\n  Transport = transport.Transport;\n\n  RawWebsocketSessionReceiver = function (superClass) {\n    extend(RawWebsocketSessionReceiver, superClass);\n\n    function RawWebsocketSessionReceiver(req, conn, server, ws1) {\n      this.ws = ws1;\n      this.prefix = server.options.prefix;\n      this.readyState = Transport.OPEN;\n      this.recv = {\n        connection: conn,\n        protocol: \"websocket-raw\"\n      };\n      this.connection = new transport.SockJSConnection(this);\n      this.decorateConnection(req);\n      server.emit('connection', this.connection);\n\n      this._end_cb = function (_this) {\n        return function () {\n          return _this.didClose();\n        };\n      }(this);\n\n      this.ws.addEventListener('close', this._end_cb);\n\n      this._message_cb = function (_this) {\n        return function (m) {\n          return _this.didMessage(m);\n        };\n      }(this);\n\n      this.ws.addEventListener('message', this._message_cb);\n    }\n\n    RawWebsocketSessionReceiver.prototype.didMessage = function (m) {\n      if (this.readyState === Transport.OPEN) {\n        this.connection.emit('data', m.data);\n      }\n    };\n\n    RawWebsocketSessionReceiver.prototype.send = function (payload) {\n      if (this.readyState !== Transport.OPEN) {\n        return false;\n      }\n\n      this.ws.send(payload);\n      return true;\n    };\n\n    RawWebsocketSessionReceiver.prototype.close = function (status, reason) {\n      if (status == null) {\n        status = 1000;\n      }\n\n      if (reason == null) {\n        reason = \"Normal closure\";\n      }\n\n      if (this.readyState !== Transport.OPEN) {\n        return false;\n      }\n\n      this.readyState = Transport.CLOSING;\n      this.ws.close(status, reason, false);\n      return true;\n    };\n\n    RawWebsocketSessionReceiver.prototype.didClose = function () {\n      var x;\n\n      if (!this.ws) {\n        return;\n      }\n\n      this.ws.removeEventListener('message', this._message_cb);\n      this.ws.removeEventListener('close', this._end_cb);\n\n      try {\n        this.ws.close(1000, \"Normal closure\", false);\n      } catch (error) {\n        x = error;\n      }\n\n      this.ws = null;\n      this.readyState = Transport.CLOSED;\n      this.connection.emit('end');\n      this.connection.emit('close');\n      return this.connection = null;\n    };\n\n    return RawWebsocketSessionReceiver;\n  }(transport.Session);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}